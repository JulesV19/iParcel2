<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåæ</text></svg>">
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>iParcel ‚Äî Twin Agricole Intelligent</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --accent: #10b981;
            --accent-light: #d1fae5;
            --accent-dark: #059669;
            --bg-light: #f8fafc;
            --panel-bg: rgba(255, 255, 255, 0.97);
            --text-main: #0f172a;
            --text-secondary: #334155;
            --text-muted: #94a3b8;
            --border: #e2e8f0;
            --border-light: #f1f5f9;
            --radius: 20px;
            --radius-sm: 12px;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.06);
            --shadow-md: 0 8px 30px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 20px 60px rgba(0, 0, 0, 0.12);
            --gradient-accent: linear-gradient(135deg, #10b981, #059669);
            --gradient-warm: linear-gradient(135deg, #f59e0b, #ef4444);
            --gradient-cool: linear-gradient(135deg, #3b82f6, #8b5cf6);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            background: var(--bg-light);
            color: var(--text-main);
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        #map {
            position: absolute;
            inset: 0;
            width: 100%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #map.sidebar-open {
            width: calc(100% - 460px);
        }

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 15;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            background: none;
            pointer-events: none;
        }

        .top-bar>* {
            pointer-events: auto;
        }

        .site-logo {
            font-size: 1.4rem;
            font-weight: 900;
            color: var(--accent-dark);
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: var(--gradient-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .top-actions {
            display: flex;
            gap: 8px;
        }

        .top-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 10px;
            background: white;
            color: var(--text-main);
            font-size: 0.82rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: inherit;
        }

        .top-btn:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .top-btn.active {
            background: var(--accent);
            color: white;
        }

        .ui-panel {
            position: absolute;
            top: 72px;
            left: 20px;
            z-index: 10;
            width: 370px;
            background: var(--panel-bg);
            padding: 0;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            max-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: var(--transition);
        }

        .ui-panel.collapsed {
            max-height: 0;
            opacity: 0;
            pointer-events: none;
        }

        .panel-header {
            padding: 20px 22px 0;
            flex-shrink: 0;
        }

        .panel-body {
            padding: 0 22px 22px;
            overflow-y: auto;
            flex: 1;
        }

        .tab-bar {
            display: flex;
            gap: 4px;
            background: var(--border-light);
            border-radius: 10px;
            padding: 3px;
            margin-bottom: 18px;
        }

        .tab-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-muted);
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
        }

        .tab-btn.active {
            background: white;
            color: var(--text-main);
            box-shadow: var(--shadow-sm);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        label {
            display: block;
            font-size: .7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin: 16px 0 6px;
        }

        .input-group {
            position: relative;
        }

        .input-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            color: var(--text-muted);
            pointer-events: none;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 11px 14px 11px 38px;
            border-radius: var(--radius-sm);
            border: 1.5px solid var(--border);
            background: #ffffff;
            color: var(--text-main);
            outline: none;
            font-size: 0.88rem;
            font-family: inherit;
            transition: var(--transition);
        }

        input[type="text"]:focus,
        select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
        }

        select {
            padding-left: 14px;
            appearance: none;
            cursor: pointer;
        }

        .range-wrap {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
            -webkit-appearance: none;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.4);
        }

        .opacity-badge {
            font-weight: 700;
            min-width: 42px;
            text-align: center;
            background: var(--accent-light);
            color: var(--accent-dark);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.82rem;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .chip {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            border: 1.5px solid var(--border);
            background: white;
            color: var(--text-secondary);
            transition: var(--transition);
            font-family: inherit;
        }

        .chip:hover {
            border-color: var(--accent);
        }

        .chip.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .legend-list {
            max-height: 260px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 7px 8px;
            border-radius: 8px;
            font-size: 0.82rem;
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-secondary);
        }

        .legend-item:hover {
            background: var(--border-light);
        }

        .legend-item.dimmed {
            opacity: 0.35;
        }

        .swatch {
            width: 16px;
            height: 16px;
            border-radius: 5px;
            flex-shrink: 0;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
        }

        .legend-count {
            margin-left: auto;
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--border-light);
            padding: 2px 6px;
            border-radius: 6px;
        }

        .quick-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 14px;
        }

        .stat-card {
            padding: 14px;
            border-radius: var(--radius-sm);
            background: var(--border-light);
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 800;
            color: var(--text-main);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 2px;
            font-weight: 500;
        }

        #side-panel {
            position: fixed;
            right: -460px;
            top: 0;
            width: 460px;
            height: 100%;
            background: #ffffff;
            z-index: 1000;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: -15px 0 40px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }

        #side-panel.open {
            right: 0;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            left: -52px;
            width: 52px;
            height: 52px;
            border: none;
            border-radius: 14px 0 0 14px;
            cursor: pointer;
            background: #ffffff;
            box-shadow: -6px 0 20px rgba(0, 0, 0, 0.08);
            font-size: 18px;
            color: var(--text-muted);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .close-btn:hover {
            color: var(--text-main);
            background: #f8fafc;
        }

        .panel-header-right {
            padding: 28px 28px 0;
            flex-shrink: 0;
        }

        .panel-content {
            padding: 0 28px 28px;
            overflow-y: auto;
            flex: 1;
        }

        .parcel-title {
            font-size: 1.3rem;
            font-weight: 800;
            margin: 0;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .culture-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.72rem;
            font-weight: 700;
            color: white;
            background: var(--gradient-accent);
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 18px 0;
        }

        .info-card {
            padding: 16px;
            border-radius: var(--radius-sm);
            background: var(--border-light);
            border: 1px solid var(--border);
            transition: var(--transition);
        }

        .info-card:hover {
            border-color: var(--accent);
        }

        .info-card .ic-icon {
            font-size: 20px;
            margin-bottom: 6px;
        }

        .info-card .ic-value {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .info-card .ic-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .side-tabs {
            display: flex;
            gap: 0;
            border-bottom: 2px solid var(--border);
            margin-bottom: 20px;
        }

        .side-tab {
            padding: 10px 16px;
            border: none;
            background: none;
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            position: relative;
            transition: var(--transition);
            font-family: inherit;
        }

        .side-tab.active {
            color: var(--accent-dark);
        }

        .side-tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent);
            border-radius: 1px;
        }

        .side-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .side-tab-content.active {
            display: block;
        }

        /* ‚îÄ‚îÄ Rotation Score Card ‚îÄ‚îÄ */
        .rotation-score-card {
            background: linear-gradient(135deg, #f0fdf4, #ecfdf5);
            border: 1.5px solid #bbf7d0;
            border-radius: var(--radius-sm);
            padding: 16px;
            margin-bottom: 18px;
            position: relative;
            overflow: hidden;
        }

        .rotation-score-card.mono {
            background: linear-gradient(135deg, #fef2f2, #fff1f2);
            border-color: #fecaca;
        }

        .rotation-score-card.moderate {
            background: linear-gradient(135deg, #fffbeb, #fef3c7);
            border-color: #fde68a;
        }

        .rotation-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .rotation-label {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
        }

        .rotation-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            color: white;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .rotation-badge.good {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .rotation-badge.moderate {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .rotation-badge.bad {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .rotation-score-ring {
            width: 52px;
            height: 52px;
            position: relative;
            margin: 0 auto 8px;
        }

        .rotation-score-ring svg {
            transform: rotate(-90deg);
        }

        .rotation-score-ring .score-text {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 800;
            color: var(--text-main);
        }

        /* ‚îÄ‚îÄ Visual Timeline Strip ‚îÄ‚îÄ */
        .timeline-strip {
            display: flex;
            gap: 3px;
            margin-bottom: 18px;
            border-radius: 8px;
            overflow: hidden;
            height: 38px;
            background: var(--border-light);
            border: 1px solid var(--border);
        }

        .strip-cell {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-width: 0;
        }

        .strip-cell:hover {
            filter: brightness(1.15);
            transform: scaleY(1.08);
        }

        .strip-cell .strip-year {
            font-size: 0.55rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            line-height: 1;
        }

        .strip-cell .strip-code {
            font-size: 0.6rem;
            font-weight: 800;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            line-height: 1;
            margin-top: 1px;
        }

        .strip-cell.current {
            box-shadow: inset 0 -3px 0 rgba(255, 255, 255, 0.6);
        }

        .strip-cell.empty {
            background: repeating-linear-gradient(45deg, #e2e8f0, #e2e8f0 4px, #f1f5f9 4px, #f1f5f9 8px);
        }

        /* ‚îÄ‚îÄ Detailed Timeline ‚îÄ‚îÄ */
        .timeline {
            position: relative;
            padding-left: 28px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, var(--accent), var(--border));
            border-radius: 1px;
        }

        .history-item {
            margin-bottom: 18px;
            position: relative;
            animation: fadeIn 0.4s ease backwards;
        }

        .history-item:nth-child(1) {
            animation-delay: 0.05s;
        }

        .history-item:nth-child(2) {
            animation-delay: 0.1s;
        }

        .history-item:nth-child(3) {
            animation-delay: 0.15s;
        }

        .history-item:nth-child(4) {
            animation-delay: 0.2s;
        }

        .history-item:nth-child(5) {
            animation-delay: 0.25s;
        }

        .history-item:nth-child(6) {
            animation-delay: 0.3s;
        }

        .history-item:nth-child(7) {
            animation-delay: 0.35s;
        }

        .history-item:nth-child(8) {
            animation-delay: 0.4s;
        }

        .history-item:nth-child(9) {
            animation-delay: 0.45s;
        }

        .timeline-dot {
            position: absolute;
            left: -24px;
            top: 4px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            border: 3px solid white;
            box-shadow: 0 0 0 2px var(--accent);
        }

        .timeline-dot.past {
            background: var(--border);
            box-shadow: 0 0 0 2px var(--border);
        }

        .timeline-dot.event-split {
            background: #f59e0b;
            box-shadow: 0 0 0 2px #f59e0b;
        }

        .timeline-dot.event-merge {
            background: #8b5cf6;
            box-shadow: 0 0 0 2px #8b5cf6;
        }

        .year-badge {
            font-weight: 800;
            color: var(--accent-dark);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .year-badge.current::after {
            content: 'Actuel';
            font-size: 0.6rem;
            background: var(--accent-light);
            color: var(--accent-dark);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .event-tag {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-size: 0.6rem;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 10px;
            color: white;
        }

        .event-tag.split {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .event-tag.merge {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }

        .event-tag.new {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }

        .parent-card {
            background: var(--border-light);
            padding: 12px;
            border-radius: var(--radius-sm);
            margin-top: 8px;
            border: 1px solid var(--border);
            transition: var(--transition);
        }

        .parent-card:hover {
            border-color: var(--accent);
        }

        .parent-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .culture-dot {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
        }

        .confidence-bar {
            height: 5px;
            background: #e2e8f0;
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            border-radius: 3px;
            background: var(--gradient-accent);
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .siblings-link {
            font-size: 0.7rem;
            color: var(--accent-dark);
            cursor: pointer;
            margin-top: 6px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .siblings-link:hover {
            opacity: 1;
            text-decoration: underline;
        }

        .weather-stats {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            font-size: 0.78rem;
            flex-wrap: wrap;
        }

        .stat-pill {
            background: white;
            border: 1px solid var(--border);
            padding: 4px 10px;
            border-radius: 8px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .chart-container {
            margin-top: 10px;
            padding: 16px;
            background: var(--border-light);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
        }

        /* FIX: suggestions doit √™tre position:absolute dans son parent position:relative */
        .suggestions {
            background: white;
            border-radius: var(--radius-sm);
            margin-top: 4px;
            border: 1.5px solid var(--border);
            overflow: hidden;
            display: none;
            box-shadow: var(--shadow-md);
            position: absolute;
            left: 0;
            right: 0;
            top: 100%;
            z-index: 20;
        }

        .suggestions.open {
            display: block;
        }

        .suggestions button {
            width: 100%;
            padding: 11px 14px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            font-size: 0.85rem;
            color: var(--text-secondary);
            transition: var(--transition);
            font-family: inherit;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .suggestions button:hover {
            background: var(--accent-light);
            color: var(--accent-dark);
        }

        .suggestions button:last-child {
            border-bottom: none;
        }

        .sug-icon {
            font-size: 14px;
            color: var(--text-muted);
        }

        .tool-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            display: flex;
            gap: 6px;
            padding: 6px;
            background: var(--panel-bg);
            border-radius: 14px;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .tool-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 10px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: inherit;
        }

        .tool-btn:hover {
            background: var(--border-light);
        }

        .tool-btn.active {
            background: var(--accent);
            color: white;
        }

        .coord-display {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 10;
            background: var(--panel-bg);
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            font-variant-numeric: tabular-nums;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            background: white;
            padding: 14px 20px;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-lg);
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-left: 4px solid var(--accent);
        }

        .toast.show {
            transform: translateX(0);
        }

        .compare-slider {
            position: absolute;
            top: 72px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            background: var(--panel-bg);
            padding: 12px 20px;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-lg);
            display: none;
            align-items: center;
            gap: 14px;
            font-size: 0.85rem;
            font-weight: 600;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .compare-slider.active {
            display: flex;
        }

        .compare-slider select {
            width: auto;
            padding: 8px 12px;
            padding-left: 12px;
        }

        .note-input {
            width: 100%;
            padding: 10px;
            border: 1.5px solid var(--border);
            border-radius: var(--radius-sm);
            font-family: inherit;
            font-size: 0.85rem;
            resize: vertical;
            min-height: 80px;
            outline: none;
            transition: var(--transition);
        }

        .note-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
        }

        .export-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: var(--radius-sm);
            background: var(--gradient-accent);
            color: white;
            font-weight: 700;
            font-size: 0.88rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
            margin-top: 12px;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.35);
        }

        @media print {

            .ui-panel,
            .top-bar,
            .tool-panel,
            .coord-display,
            .close-btn {
                display: none !important;
            }

            #side-panel {
                position: relative !important;
                right: 0 !important;
                width: 100% !important;
                box-shadow: none !important;
            }

            #map {
                display: none !important;
            }
        }

        /* ‚îÄ‚îÄ Parcel Viz Mini-Map ‚îÄ‚îÄ */
        #parcel-viz-svg {
            position: relative;
        }

        #parcel-viz-svg .maplibregl-canvas {
            border-radius: var(--radius-sm);
        }

        #parcel-viz-svg .maplibregl-ctrl-attrib {
            display: none !important;
        }

        .viz-legend-item {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.72rem;
            color: var(--text-secondary);
            margin-right: 12px;
            margin-bottom: 4px;
        }

        .viz-legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
        }

        .skeleton {
            background: linear-gradient(90deg, #f1f5f9 25%, #e2e8f0 50%, #f1f5f9 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 8px;
            height: 16px;
            margin: 6px 0;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        @media (max-width: 768px) {
            .ui-panel {
                width: calc(100% - 40px);
                left: 20px;
            }

            #side-panel {
                width: 100%;
                right: -100%;
            }

            #map.sidebar-open {
                width: 0;
            }

            .tool-panel {
                bottom: 80px;
            }
        }

        /* ‚îÄ‚îÄ √âcran de chargement ‚îÄ‚îÄ */
        #loader {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: #0a1628;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.7s ease, visibility 0.7s ease;
        }

        #loader.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loader-grid {
            position: absolute;
            inset: 0;
            overflow: hidden;
            opacity: 0.07;
        }

        .loader-grid-inner {
            position: absolute;
            inset: -10%;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 3px;
            transform: rotate(-8deg) scale(1.2);
        }

        .loader-cell {
            border-radius: 4px;
            background: #10b981;
            animation: cellPulse 3s ease-in-out infinite;
        }

        .loader-cell:nth-child(3n) {
            animation-delay: 0.3s;
            background: #3b82f6;
        }

        .loader-cell:nth-child(5n) {
            animation-delay: 0.6s;
            background: #f59e0b;
        }

        .loader-cell:nth-child(7n) {
            animation-delay: 0.9s;
            background: #a78bfa;
        }

        .loader-cell:nth-child(11n) {
            animation-delay: 1.2s;
            background: #f87171;
        }

        @keyframes cellPulse {

            0%,
            100% {
                opacity: 0.4;
                transform: scale(0.95);
            }

            50% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .loader-logo {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            animation: logoEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) both;
        }

        @keyframes logoEntrance {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.8);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .loader-icon-wrap {
            width: 90px;
            height: 90px;
            border-radius: 26px;
            background: linear-gradient(135deg, #10b981, #059669);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 44px;
            position: relative;
            animation: iconGlow 2s ease-in-out infinite;
        }

        .loader-icon-wrap::after {
            content: '';
            position: absolute;
            inset: -8px;
            border-radius: 34px;
            border: 2px solid rgba(16, 185, 129, 0.3);
            animation: ringExpand 2s ease-in-out infinite;
        }

        @keyframes iconGlow {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4), 0 20px 40px rgba(16, 185, 129, 0.3);
            }

            50% {
                box-shadow: 0 0 0 16px rgba(16, 185, 129, 0), 0 20px 40px rgba(16, 185, 129, 0.5);
            }
        }

        @keyframes ringExpand {
            0% {
                transform: scale(1);
                opacity: 0.6;
            }

            100% {
                transform: scale(1.4);
                opacity: 0;
            }
        }

        .loader-title {
            font-size: 2.4rem;
            font-weight: 900;
            color: white;
            letter-spacing: -0.5px;
            margin: 0;
        }

        .loader-title span {
            color: #10b981;
        }

        .loader-subtitle {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 500;
            letter-spacing: 0.5px;
            margin-top: -12px;
        }

        .loader-progress-wrap {
            position: relative;
            z-index: 1;
            width: 260px;
            margin-top: 48px;
            animation: logoEntrance 0.8s 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) both;
        }

        .loader-progress-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .loader-progress-bar {
            height: 100%;
            width: 0%;
            border-radius: 2px;
            background: linear-gradient(90deg, #10b981, #34d399);
            transition: width 0.4s ease;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.6);
        }

        .loader-status {
            margin-top: 12px;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 500;
            text-align: center;
            min-height: 1.2em;
            transition: opacity 0.3s ease;
        }

        .loader-dots {
            display: inline-flex;
            gap: 4px;
            margin-left: 2px;
        }

        .loader-dots span {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            animation: dotBounce 1.2s ease-in-out infinite;
        }

        .loader-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loader-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes dotBounce {

            0%,
            80%,
            100% {
                transform: translateY(0);
                opacity: 0.4;
            }

            40% {
                transform: translateY(-5px);
                opacity: 1;
            }
        }

        /* ‚îÄ‚îÄ Heatmap Styles ‚îÄ‚îÄ */
        .heatmap-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }

        .heatmap-branch {
            background: var(--border-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 12px;
        }

        .branch-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.75rem;
        }

        .health-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }

        .heatmap-row {
            display: flex;
            gap: 4px;
            height: 32px;
        }

        .heatmap-cell {
            flex: 1;
            border-radius: 4px;
            position: relative;
            cursor: help;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .heatmap-cell:hover {
            transform: scale(1.15);
            z-index: 5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>

<body>

    <!-- ‚îÄ‚îÄ √âcran de chargement ‚îÄ‚îÄ -->
    <div id="loader">
        <div class="loader-grid">
            <div class="loader-grid-inner">
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
                <div class="loader-cell"></div>
            </div>
        </div>
        <div class="loader-logo">
            <div class="loader-icon-wrap">üåæ</div>
            <p class="loader-title">i<span>Parcel</span></p>
            <p class="loader-subtitle">Twin Agricole Intelligent</p>
        </div>
        <div class="loader-progress-wrap">
            <div class="loader-progress-track">
                <div class="loader-progress-bar" id="loader-bar"></div>
            </div>
            <div class="loader-status" id="loader-status">
                Initialisation<div class="loader-dots"><span></span><span></span><span></span></div>
            </div>
        </div>
    </div>


    <!-- Top Bar -->
    <div class="top-bar">
        <div class="site-logo">
            <div class="logo-icon">üåæ</div>
            iParcel
        </div>
        <div class="top-actions">
            <button class="top-btn" id="btn-toggle-panel" onclick="toggleLeftPanel()">üìê Panneau</button>
            <button class="top-btn" id="btn-measure" onclick="toggleMeasure()">üìè Mesurer</button>
            <button class="top-btn" id="btn-compare" onclick="toggleCompare()">üîÑ Comparer</button>
            <button class="top-btn" id="btn-screenshot" onclick="takeScreenshot()">üì∏ Capture</button>
            <button class="top-btn" id="btn-basemap" onclick="cycleBasemap()">üó∫Ô∏è Fond</button>
        </div>
    </div>

    <!-- Compare Slider -->
    <div class="compare-slider" id="compare-bar">
        <span>Gauche:</span>
        <select id="compare-left">
            <option value="2023">2023</option>
            <option value="2022">2022</option>
            <option value="2021">2021</option>
            <option value="2020">2020</option>
            <option value="2019">2019</option>
            <option value="2018">2018</option>
            <option value="2017">2017</option>
            <option value="2016">2016</option>
        </select>
        <span>Droite:</span>
        <select id="compare-right">
            <option value="2022">2022</option>
            <option value="2023">2023</option>
            <option value="2021">2021</option>
            <option value="2020">2020</option>
            <option value="2019">2019</option>
            <option value="2018">2018</option>
            <option value="2017">2017</option>
            <option value="2016">2016</option>
        </select>
        <button class="top-btn active" onclick="applyCompare()">Appliquer</button>
        <button class="top-btn" onclick="toggleCompare()">‚úï</button>
    </div>

    <!-- Left Panel -->
    <div class="ui-panel" id="left-panel">
        <div class="panel-header">
            <div class="tab-bar">
                <button class="tab-btn active" onclick="switchTab(this, 'tab-search')">üîç Recherche</button>
                <button class="tab-btn" onclick="switchTab(this, 'tab-layers')">üóÇÔ∏è Couches</button>
                <button class="tab-btn" onclick="switchTab(this, 'tab-stats')">üìä Stats</button>
            </div>
        </div>
        <div class="panel-body">
            <!-- Tab Recherche -->
            <div class="tab-content active" id="tab-search">
                <label>üìç Localisation</label>
                <!-- FIX: position:relative sur le wrapper pour que les suggestions se positionnent correctement -->
                <div class="input-group" style="position:relative;">
                    <span class="input-icon">üîé</span>
                    <input type="text" id="address-input" placeholder="Chercher une commune, adresse..."
                        autocomplete="off">
                    <div id="suggestions" class="suggestions"></div>
                </div>

                <label>üìÖ Ann√©e de Campagne</label>
                <select id="year-select">
                    <option value="2023">üå± 2023 ‚Äî Campagne actuelle</option>
                    <option value="2022">üåø 2022</option>
                    <option value="2021">üåø 2021</option>
                    <option value="2020">üåø 2020</option>
                    <option value="2019">üåø 2019</option>
                    <option value="2018">üåø 2018</option>
                    <option value="2017">üåø 2017</option>
                    <option value="2016">üåø 2016</option>
                </select>

                <label>üîÜ Transparence des parcelles</label>
                <div class="range-wrap">
                    <input type="range" id="opacity-slider" min="0" max="100" value="70">
                    <div class="opacity-badge"><span id="opacity-value">70</span>%</div>
                </div>

                <label>üè∑Ô∏è Filtrer par groupe</label>
                <div class="filter-chips" id="filter-chips"></div>
            </div>

            <!-- Tab Couches -->
            <div class="tab-content" id="tab-layers">
                <label>üó∫Ô∏è Fond de carte</label>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:6px;">
                    <button class="chip active" onclick="setBasemap('satellite', this)">üõ∞Ô∏è Satellite</button>
                    <button class="chip" onclick="setBasemap('streets', this)">üó∫Ô∏è Rues</button>
                    <button class="chip" onclick="setBasemap('terrain', this)">‚õ∞Ô∏è Terrain</button>
                    <button class="chip" onclick="setBasemap('dark', this)">üåô Sombre</button>
                </div>

                <label>üìê Contours des parcelles</label>
                <div class="range-wrap">
                    <input type="range" id="outline-slider" min="0" max="4" value="1" step="0.5">
                    <div class="opacity-badge"><span id="outline-value">1</span>px</div>
                </div>

                <label>üé® L√©gende des cultures</label>
                <div id="legend-list" class="legend-list"></div>
            </div>

            <!-- Tab Stats -->
            <div class="tab-content" id="tab-stats">
                <label>üìä Statistiques de la vue</label>
                <div class="quick-stats" id="quick-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-parcels">‚Äî</div>
                        <div class="stat-label">Parcelles visibles</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-surface">‚Äî</div>
                        <div class="stat-label">Surface totale (ha)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-cultures">‚Äî</div>
                        <div class="stat-label">Types de cultures</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-zoom">‚Äî</div>
                        <div class="stat-label">Niveau de zoom</div>
                    </div>
                </div>
                <div class="chart-container" style="margin-top:16px;">
                    <canvas id="stats-chart" height="200"></canvas>
                </div>
                <button class="export-btn" onclick="exportCSV()">üì• Exporter les donn√©es visibles (CSV)</button>
                <div id="lineage-global-stats"></div>
            </div>
        </div>
    </div>

    <!-- Side Panel -->
    <div id="side-panel">
        <button class="close-btn" onclick="toggleSidebar(false)">‚úï</button>
        <div class="panel-header-right">
            <h2 id="parcel-name" class="parcel-title">Analyse parcellaire</h2>
            <div id="field-info" style="margin: 12px 0; font-size: 0.9rem;">
                <p style="color:var(--text-muted);">Cliquez sur une parcelle pour voir les d√©tails.</p>
            </div>
        </div>
        <div class="panel-content">
            <div class="side-tabs">
                <button class="side-tab active" onclick="switchSideTab(this, 'stab-info')">‚ÑπÔ∏è Infos</button>
                <button class="side-tab" onclick="switchSideTab(this, 'stab-history')">üìú Historique</button>
                <button class="side-tab" onclick="switchSideTab(this, 'stab-parcelle')">üó∫Ô∏è Parcelle</button>
                <button class="side-tab" onclick="switchSideTab(this, 'stab-notes')">üìù Notes</button>
                <button class="side-tab" onclick="switchSideTab(this, 'stab-heatmap')">üìä Heatmap</button>
            </div>

            <div class="side-tab-content active" id="stab-info">
                <div class="info-grid" id="info-grid"></div>
                <label>üå°Ô∏è Conditions m√©t√©o (saison)</label>
                <div class="chart-container">
                    <canvas id="weather-chart" height="180"></canvas>
                </div>
            </div>
            <div class="side-tab-content" id="stab-heatmap">
                <label>üó∫Ô∏è Carte de vigueur de rotation</label>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 12px;">
                    Cette carte divise votre parcelle en zones selon la qualit√© de l'historique cultural de chaque
                    fragment.
                </div>

                <div id="spatial-heatmap-container"
                    style="height: 300px; border-radius: var(--radius-sm); border: 1px solid var(--border); overflow: hidden; position: relative; background: #f8fafc;">
                </div>

                <div class="info-grid" style="margin-top: 15px; grid-template-columns: 1fr;">
                    <div class="info-card" id="heatmap-status-card" style="border-left: 4px solid var(--accent);">
                        <div class="ic-label" id="heatmap-score-label">Analyse en cours...</div>
                        <div class="ic-value" id="heatmap-score-value">‚Äî</div>
                    </div>
                </div>
            </div>

            <div class="side-tab-content" id="stab-history">
                <div id="rotation-score"></div>
                <div id="timeline-strip-container"></div>
                <div id="siblings-container"></div>
                <div class="timeline" id="history-list"></div>
            </div>

            <div class="side-tab-content" id="stab-parcelle">
                <div id="parcel-viz-controls">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
                        <span id="parcel-viz-year"
                            style="font-size:1.4rem;font-weight:900;color:var(--accent-dark);">2023</span>
                        <div style="display:flex;gap:6px;">
                            <button class="top-btn" onclick="parcelVizPrev()" style="padding:6px 10px;">‚óÄ</button>
                            <button class="top-btn" onclick="parcelVizPlay()" id="parcel-viz-play-btn"
                                style="padding:6px 10px;">‚ñ∂ Animer</button>
                            <button class="top-btn" onclick="parcelVizNext()" style="padding:6px 10px;">‚ñ∂</button>
                        </div>
                    </div>
                    <input type="range" id="parcel-viz-slider" min="0" max="7" value="7"
                        style="width:100%;accent-color:var(--accent);">
                    <div id="parcel-viz-year-labels"
                        style="display:flex;justify-content:space-between;font-size:0.65rem;color:var(--text-muted);margin-top:2px;">
                    </div>
                </div>
                <div id="parcel-viz-svg"
                    style="margin-top:14px;border:1px solid var(--border);border-radius:var(--radius-sm);overflow:hidden;position:relative;height:320px;">
                </div>
                <div id="parcel-viz-legend" style="margin-top:10px;"></div>
                <div id="parcel-viz-info" style="margin-top:8px;font-size:0.78rem;color:var(--text-secondary);"></div>
            </div>

            <div class="side-tab-content" id="stab-notes">
                <label>üìù Notes sur cette parcelle</label>
                <textarea class="note-input" id="parcel-note" placeholder="Ajouter des observations..."></textarea>
                <button class="export-btn" onclick="saveNote()" style="margin-top:10px;">üíæ Sauvegarder la note</button>
                <label style="margin-top:20px;">üìã Notes pr√©c√©dentes</label>
                <div id="saved-notes" style="font-size:0.85rem; color:var(--text-muted);">Aucune note.</div>
            </div>

            <button class="export-btn" onclick="exportParcelPDF()" style="margin-top:20px;">
                üñ®Ô∏è Exporter le rapport (PDF)
            </button>
        </div>
    </div>

    <!-- Bottom Tool Bar -->
    <div class="tool-panel">
        <button class="tool-btn" onclick="map.zoomIn()">‚ûï Zoom</button>
        <button class="tool-btn" onclick="map.zoomOut()">‚ûñ D√©zoom</button>
        <button class="tool-btn" id="btn-locate" onclick="geolocate()">üìç Ma position</button>
        <button class="tool-btn" onclick="resetView()">üè† Vue initiale</button>
        <button class="tool-btn" onclick="map.setBearing(0); map.setPitch(0);">üß≠ Nord</button>
        <button class="tool-btn" id="btn-3d" onclick="toggle3D()">üèîÔ∏è 3D</button>
    </div>

    <!-- Coordinates -->
    <div class="coord-display" id="coord-display">48.3700¬∞ N, 3.2900¬∞ E ‚Äî Zoom 12</div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <div id="map"></div>

    <script>
        // ‚îÄ‚îÄ Globals ‚îÄ‚îÄ
        const years = ["2023", "2022", "2021", "2020", "2019", "2018", "2017", "2016"];
        const cropLabels = {};
        const groupLabels = new Map();
        let lineageData = null;
        let lineageStats = null;
        let parentIndex = null;
        let bucketCache = {};  // Cache des buckets d√©j√† charg√©s: { "44": {parcelles, filiations}, ... }     // Reverse index: parentId+year -> [childIds]
        let compareMode = false;
        let measureMode = false;
        let measurePoints = [];
        let measureMarkers = [];
        let is3D = false;
        let currentParcelId = null;
        let statsChart = null;
        let weatherChart = null;
        let activeFilters = new Set();
        let basemapIndex = 0;
        // FIX: flag pour s'assurer qu'on n'agit sur la carte qu'apr√®s map.on('load')
        let mapReady = false;

        const cultureColors = {
            "1": "#facc15", "2": "#fb923c", "3": "#4ade80", "4": "#f87171",
            "5": "#a3e635", "6": "#fbbf24", "7": "#60a5fa", "8": "#c084fc",
            "9": "#2dd4bf", "10": "#f472b6", "11": "#a78bfa", "12": "#34d399",
            "13": "#fca5a5", "14": "#7dd3fc", "15": "#d8b4fe", "16": "#bef264",
            "17": "#fdba74", "18": "#fb7185", "19": "#67e8f9", "20": "#86efac",
            "21": "#fde68a", "22": "#c4b5fd", "23": "#a5f3fc", "24": "#fecaca",
            "25": "#bbf7d0", "26": "#ddd6fe", "27": "#fed7aa", "28": "#fecdd3",
            "default": "#94a3b8"
        };

        const basemaps = [
            { name: "Satellite", tiles: "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}" },
            { name: "Rues", tiles: "https://tile.openstreetmap.org/{z}/{x}/{y}.png" },
            { name: "Terrain", tiles: "https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}" },
            { name: "Sombre", tiles: "https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png" }
        ];


        // ‚îÄ‚îÄ Loader progress steps ‚îÄ‚îÄ
        function loaderStep(pct, msg) {
            const bar = document.getElementById('loader-bar');
            const status = document.getElementById('loader-status');
            if (bar) bar.style.width = pct + '%';
            if (status) status.innerHTML = msg + '<div class="loader-dots"><span></span><span></span><span></span></div>';
        }
        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.classList.add('hidden');
                setTimeout(() => loader.remove(), 800);
            }
        }
        loaderStep(10, 'Chargement de la carte');

        // --- 1. CONFIGURATION DU PROTOCOLE PMTILES ---
        // Cette partie DOIT √™tre au tout d√©but, avant de cr√©er la carte.
        const protocol = new pmtiles.Protocol();
        maplibregl.addProtocol("pmtiles", protocol.tile.bind(protocol));

        // --- 2. INITIALISATION DE LA CARTE ---
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    "basemap": { type: "raster", tiles: [basemaps[0].tiles], tileSize: 256 }
                },
                layers: [{ id: "basemap-layer", type: "raster", source: "basemap" }]
            },
            center: [2.35, 48.85],
            zoom: 12,
            attributionControl: false
        });
        map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
        loaderStep(30, 'Connexion aux tuiles');
        map.addControl(new maplibregl.ScaleControl({ maxWidth: 200 }), 'bottom-left');

        map.on('load', () => {
            loaderStep(60, 'Chargement des parcelles');
            mapReady = true;
            const year = document.getElementById('year-select').value;

            try { ensureLayer(year); } catch (e) { console.warn('ensureLayer:', e); }

            loaderStep(80, 'Chargement des donn√©es');
            init().then(() => {
                loaderStep(95, 'Finalisation');
                updateStats();
            });

            // Masquer le loader d√®s que la carte est idle (tuiles rendues) OU apr√®s 6s max
            const loaderTimeout = setTimeout(hideLoader, 6000);
            map.once('idle', () => {
                clearTimeout(loaderTimeout);
                setTimeout(hideLoader, 300);
            });
        });

        // S√©curit√© suppl√©mentaire : si map.on('load') ne se d√©clenche jamais (r√©seau KO)
        setTimeout(() => hideLoader(), 10000);

        // FIX: mise √† jour des coordonn√©es en temps r√©el
        map.on('mousemove', (e) => {
            const { lng, lat } = e.lngLat;
            const zoom = map.getZoom().toFixed(1);
            const latStr = lat >= 0 ? `${lat.toFixed(4)}¬∞ N` : `${Math.abs(lat).toFixed(4)}¬∞ S`;
            const lngStr = lng >= 0 ? `${lng.toFixed(4)}¬∞ E` : `${Math.abs(lng).toFixed(4)}¬∞ W`;
            document.getElementById('coord-display').textContent = `${latStr}, ${lngStr} ‚Äî Zoom ${zoom}`;
        });

        // FIX: mise √† jour des stats au changement de vue
        map.on('moveend', updateStats);
        map.on('zoomend', () => {
            document.getElementById('stat-zoom').textContent = map.getZoom().toFixed(1);
            updateStats();
        });

        // FIX: clic sur les parcelles ‚Äî g√©r√© apr√®s que les couches soient pr√™tes
        map.on('click', (e) => {
            if (measureMode) {
                addMeasurePoint(e.lngLat);
                return;
            }
            const year = document.getElementById('year-select').value;
            const lyrId = `lyr-${year}`;
            if (!map.getLayer(lyrId)) return;

            const features = map.queryRenderedFeatures(e.point, { layers: [lyrId] });
            if (!features.length) return;

            const feature = features[0];
            const props = feature.properties;

            // Debug : affiche toutes les propri√©t√©s dans la console pour identifier la bonne cl√© d'ID
            // ID confirm√© : props.ID_PARCEL (ex: "8393489")
            const parcelId = String(
                feature.id                          // ID natif du feature MVT/PMTile
                ?? props.ID_PARCEL
                ?? props.id_parcel
                ?? props.ID
                ?? props.id
                ?? props.NUMERO
                ?? props.numero
                ?? props.FID
                ?? `${props.CODE_CULTU}_${e.lngLat.lat.toFixed(5)}_${e.lngLat.lng.toFixed(5)}`
            );
            console.log('[iParcel] parcelId r√©solu =', parcelId, '| dans lineage ?', !!(lineageData && lineageData[parcelId]));
            highlightFeature(feature);
            showDetails(e, parcelId, props);
        });

        // Curseur survol
        map.on('mouseenter', (e) => {
            const year = document.getElementById('year-select').value;
            const lyrId = `lyr-${year}`;
            if (map.getLayer(lyrId)) map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', (e) => {
            if (!measureMode) map.getCanvas().style.cursor = '';
        });

        // ‚îÄ‚îÄ Toast ‚îÄ‚îÄ
        function showToast(msg, icon = "‚úÖ") {
            const t = document.getElementById('toast');
            t.innerHTML = `<span>${icon}</span> ${msg}`;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        // ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ
        function switchTab(btn, tabId) {
            btn.closest('.tab-bar').querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            btn.closest('.ui-panel').querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        }

        function switchSideTab(btn, tabId) {
            btn.closest('.side-tabs').querySelectorAll('.side-tab').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            document.querySelectorAll('.side-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        }

        // ‚îÄ‚îÄ Left Panel Toggle ‚îÄ‚îÄ
        function toggleLeftPanel() {
            const p = document.getElementById('left-panel');
            p.classList.toggle('collapsed');
            document.getElementById('btn-toggle-panel').classList.toggle('active');
        }

        // ‚îÄ‚îÄ Basemap ‚îÄ‚îÄ
        // FIX: fonction utilitaire pour remplacer le fond de carte en toute s√©curit√©
        function swapBasemap(idx) {
            if (!mapReady) return;
            const bm = basemaps[idx];
            try {
                if (map.getLayer('basemap-layer')) map.removeLayer('basemap-layer');
                if (map.getSource('basemap')) map.removeSource('basemap');
            } catch (e) { }
            map.addSource('basemap', { type: 'raster', tiles: [bm.tiles], tileSize: 256 });
            const layers = map.getStyle().layers;
            const firstOther = layers.find(l => l.id !== 'basemap-layer');
            map.addLayer({ id: 'basemap-layer', type: 'raster', source: 'basemap' },
                firstOther ? firstOther.id : undefined);
        }

        function setBasemap(name, btn) {
            const idx = basemaps.findIndex(b => b.name.toLowerCase().includes(name.toLowerCase()));
            if (idx < 0) return;
            basemapIndex = idx;
            swapBasemap(idx);
            if (btn) {
                btn.closest('div').querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
            }
            showToast(`Fond de carte: ${basemaps[idx].name}`, "üó∫Ô∏è");
        }

        function cycleBasemap() {
            basemapIndex = (basemapIndex + 1) % basemaps.length;
            swapBasemap(basemapIndex);
            showToast(`Fond: ${basemaps[basemapIndex].name}`, "üó∫Ô∏è");
        }

        // ‚îÄ‚îÄ 3D Toggle ‚îÄ‚îÄ
        function toggle3D() {
            is3D = !is3D;
            map.easeTo({ pitch: is3D ? 60 : 0, duration: 500 });
            document.getElementById('btn-3d').classList.toggle('active', is3D);
            showToast(is3D ? "Vue 3D activ√©e" : "Vue 2D", "üèîÔ∏è");
        }

        // ‚îÄ‚îÄ Geolocation ‚îÄ‚îÄ
        function geolocate() {
            if (!navigator.geolocation) return showToast("G√©olocalisation non disponible", "‚ö†Ô∏è");
            navigator.geolocation.getCurrentPosition(pos => {
                map.flyTo({ center: [pos.coords.longitude, pos.coords.latitude], zoom: 14 });
                new maplibregl.Marker({ color: '#3b82f6' })
                    .setLngLat([pos.coords.longitude, pos.coords.latitude])
                    .addTo(map);
                showToast("Position trouv√©e", "üìç");
            }, () => showToast("Position refus√©e", "‚ö†Ô∏è"));
        }

        function resetView() {
            map.flyTo({ center: [-3.29, 48.37], zoom: 12, pitch: 0, bearing: 0 });
        }

        // ‚îÄ‚îÄ Measure Tool ‚îÄ‚îÄ
        function toggleMeasure() {
            measureMode = !measureMode;
            document.getElementById('btn-measure').classList.toggle('active', measureMode);
            if (!measureMode) {
                clearMeasure();
                showToast("Mesure d√©sactiv√©e", "üìè");
            } else {
                showToast("Cliquez sur la carte pour mesurer", "üìè");
            }
            map.getCanvas().style.cursor = measureMode ? 'crosshair' : '';
        }

        function clearMeasure() {
            measurePoints = [];
            measureMarkers.forEach(m => m.remove());
            measureMarkers = [];
            try {
                if (map.getLayer('measure-line-layer')) map.removeLayer('measure-line-layer');
                if (map.getSource('measure-line')) map.removeSource('measure-line');
            } catch (e) { }
        }

        function addMeasurePoint(lngLat) {
            measurePoints.push([lngLat.lng, lngLat.lat]);
            const el = document.createElement('div');
            el.style.cssText = 'width:10px;height:10px;background:#3b82f6;border-radius:50%;border:2px solid white;box-shadow:0 2px 6px rgba(0,0,0,0.3)';
            const m = new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
            measureMarkers.push(m);

            if (measurePoints.length > 1) {
                const geojson = { type: 'Feature', geometry: { type: 'LineString', coordinates: measurePoints } };
                if (map.getSource('measure-line')) {
                    map.getSource('measure-line').setData(geojson);
                } else {
                    map.addSource('measure-line', { type: 'geojson', data: geojson });
                    map.addLayer({
                        id: 'measure-line-layer', type: 'line', source: 'measure-line',
                        paint: { 'line-color': '#3b82f6', 'line-width': 3, 'line-dasharray': [2, 2] }
                    });
                }
                showToast(`Distance: ${calcTotalDistance(measurePoints)}`, "üìè");
            }
        }

        function calcTotalDistance(pts) {
            let total = 0;
            for (let i = 1; i < pts.length; i++) {
                total += haversine(pts[i - 1][1], pts[i - 1][0], pts[i][1], pts[i][0]);
            }
            return total < 1 ? `${Math.round(total * 1000)} m` : `${total.toFixed(2)} km`;
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // ‚îÄ‚îÄ Compare Mode ‚îÄ‚îÄ
        function toggleCompare() {
            compareMode = !compareMode;
            document.getElementById('compare-bar').classList.toggle('active', compareMode);
            document.getElementById('btn-compare').classList.toggle('active', compareMode);
            if (!compareMode) {
                const selected = document.getElementById('year-select').value;
                const op = document.getElementById('opacity-slider').value / 100;
                years.forEach(y => {
                    const lyr = `lyr-${y}`;
                    if (map.getLayer(lyr)) {
                        map.setPaintProperty(lyr, 'fill-opacity', y === selected ? op : 0);
                    }
                });
            }
        }

        function applyCompare() {
            if (!mapReady) return;
            const left = document.getElementById('compare-left').value;
            const right = document.getElementById('compare-right').value;
            ensureLayer(left);
            ensureLayer(right);
            const op = document.getElementById('opacity-slider').value / 100;
            years.forEach(y => {
                const lyr = `lyr-${y}`;
                if (map.getLayer(lyr)) {
                    if (y === left) map.setPaintProperty(lyr, 'fill-opacity', op);
                    else if (y === right) map.setPaintProperty(lyr, 'fill-opacity', op * 0.5);
                    else map.setPaintProperty(lyr, 'fill-opacity', 0);
                }
            });
            showToast(`Comparaison ${left} vs ${right}`, "üîÑ");
        }

        // ‚îÄ‚îÄ Screenshot ‚îÄ‚îÄ
        function takeScreenshot() {
            map.once('render', () => {
                const canvas = map.getCanvas();
                canvas.toBlob(blob => {
                    if (!blob) { showToast("√âchec de la capture", "‚ö†Ô∏è"); return; }
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `iparcel-capture-${new Date().toISOString().slice(0, 10)}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast("Capture t√©l√©charg√©e", "üì∏");
                });
            });
            map.triggerRepaint();
        }

        // ‚îÄ‚îÄ Data Init ‚îÄ‚îÄ
        async function init() {
            // Chargement du CSV : fetch en ArrayBuffer + d√©codage Windows-1252 via TextDecoder
            // (PapaParse avec encoding:"windows-1252" ne d√©code pas correctement les accents dans tous les navigateurs)
            try {
                const csvResponse = await fetch("REF_CULTURES_GROUPES_CULTURES_2023.csv");
                if (csvResponse.ok) {
                    const buffer = await csvResponse.arrayBuffer();
                    const text = new TextDecoder("windows-1252").decode(buffer);
                    const res = Papa.parse(text, { header: true, delimiter: ";" });
                    res.data.forEach(row => {
                        if (row.CODE_CULTURE) cropLabels[row.CODE_CULTURE.trim()] = row.LIBELLE_CULTURE;
                        if (row.CODE_GROUPE_CULTURE) groupLabels.set(row.CODE_GROUPE_CULTURE.trim(), row.LIBELLE_GROUPE_CULTURE);
                    });
                }
            } catch (e) {
                console.log("CSV de r√©f√©rence non trouv√©.");
            }
            renderLegend();
            renderFilterChips();
            updateMapColors();

        }

        renderLineageGlobalStats();

        // ‚îÄ‚îÄ Legend ‚îÄ‚îÄ
        function renderLegend() {
            const box = document.getElementById("legend-list");
            if (groupLabels.size === 0) {
                box.innerHTML = '<div style="color:var(--text-muted);font-size:0.8rem;padding:8px;">Chargez un fichier CSV de r√©f√©rence pour afficher la l√©gende.</div>';
                return;
            }
            let html = "";
            groupLabels.forEach((lib, code) => {
                const color = cultureColors[code] || cultureColors.default;
                html += `<div class="legend-item" onclick="toggleLegendFilter('${code}', this)" data-code="${code}">
            <div class="swatch" style="background:${color}"></div>
            <span>${lib}</span>
        </div>`;
            });
            box.innerHTML = html;
        }

        function renderFilterChips() {
            const box = document.getElementById("filter-chips");
            let html = '<button class="chip active" onclick="clearFilters(this)">Toutes</button>';
            groupLabels.forEach((lib, code) => {
                html += `<button class="chip" onclick="toggleChipFilter('${code}', this)">${lib}</button>`;
            });
            box.innerHTML = html;
        }

        function toggleLegendFilter(code, el) {
            el.classList.toggle('dimmed');
            if (activeFilters.has(code)) activeFilters.delete(code);
            else activeFilters.add(code);
            applyFilter();
        }

        function toggleChipFilter(code, btn) {
            btn.classList.toggle('active');
            if (activeFilters.has(code)) activeFilters.delete(code);
            else activeFilters.add(code);
            applyFilter();
        }

        function clearFilters(btn) {
            activeFilters.clear();
            document.querySelectorAll('#filter-chips .chip').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            document.querySelectorAll('.legend-item').forEach(l => l.classList.remove('dimmed'));
            applyFilter();
        }

        function applyFilter() {
            const year = document.getElementById('year-select').value;
            const lyr = `lyr-${year}`;
            if (!map.getLayer(lyr)) return;
            if (activeFilters.size === 0) {
                map.setFilter(lyr, null);
            } else {
                // FIX: expression MapLibre correcte pour filtrer par valeurs multiples
                map.setFilter(lyr, ['in', ['get', 'CODE_GROUP'], ['literal', [...activeFilters]]]);
            }
        }

        // ‚îÄ‚îÄ Map Colors ‚îÄ‚îÄ
        function getMapColorExpression() {
            const expression = ["match", ["get", "CODE_GROUP"]];
            for (const [code, color] of Object.entries(cultureColors)) {
                if (code !== "default") expression.push(code, color);
            }
            expression.push(cultureColors.default);
            return expression;
        }

        function updateMapColors() {
            years.forEach(y => {
                const lyrId = `lyr-${y}`;
                if (map.getLayer(lyrId)) {
                    map.setPaintProperty(lyrId, "fill-color", getMapColorExpression());
                }
            });
        }

        function ensureLayer(year) {
            if (!mapReady) return;
            const srcId = `src-${year}`;
            const lyrId = `lyr-${year}`;
            if (!map.getSource(srcId)) {
                // PMTiles : le fichier doit √™tre plac√© dans /data/{year}.pmtiles
                // Le protocole pmtiles:// est g√©r√© par la librairie pmtiles.js
                map.addSource(srcId, {
                    type: "vector",
                    // Ligne ~810 dans la fonction ensureLayer
                    url: `pmtiles://https://huggingface.co/datasets/Juckles19/iparcel-public/resolve/main/${year}.pmtiles`
                });
            }
            if (!map.getLayer(lyrId)) {
                map.addLayer({
                    id: lyrId, type: "fill", source: srcId, "source-layer": "parcelles",
                    paint: {
                        "fill-color": getMapColorExpression(),
                        "fill-opacity": year === document.getElementById('year-select').value
                            ? document.getElementById('opacity-slider').value / 100 : 0,
                        "fill-outline-color": "rgba(255,255,255,0.6)"
                    }
                });
                map.addLayer({
                    id: `${lyrId}-outline`, type: "line", source: srcId, "source-layer": "parcelles",
                    paint: {
                        "line-color": "rgba(255,255,255,0.8)",
                        "line-width": parseFloat(document.getElementById('outline-slider').value)
                    }
                });
            }
        }

        // ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ
        let highlightedFeature = null;

        function clearHighlight() {
            if (!mapReady) return;
            try {
                if (map.getSource('highlight-src')) {
                    map.getSource('highlight-src').setData({ type: 'FeatureCollection', features: [] });
                }
            } catch (e) { }
            highlightedFeature = null;
        }

        function highlightFeature(feature) {
            if (!mapReady) return;
            // Create highlight source+layers if they don't exist yet
            if (!map.getSource('highlight-src')) {
                map.addSource('highlight-src', {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: [] }
                });
                map.addLayer({
                    id: 'highlight-fill', type: 'fill', source: 'highlight-src',
                    paint: {
                        'fill-color': '#facc15',
                        'fill-opacity': 0.35
                    }
                });
                map.addLayer({
                    id: 'highlight-outline', type: 'line', source: 'highlight-src',
                    paint: {
                        'line-color': '#facc15',
                        'line-width': 3,
                        'line-opacity': 1
                    }
                });
            }
            // Set the clicked feature as highlight data
            map.getSource('highlight-src').setData({
                type: 'FeatureCollection',
                features: [{ type: 'Feature', geometry: feature.geometry, properties: {} }]
            });
            highlightedFeature = feature;
        }

        function toggleSidebar(open) {
            document.getElementById('side-panel').classList.toggle('open', open);
            document.getElementById('map').classList.toggle('sidebar-open', open);
            if (!open) { clearHighlight(); destroyMiniMap(); }
            setTimeout(() => map.resize(), 400);
        }

        // ‚îÄ‚îÄ Stats Panel ‚îÄ‚îÄ
        // FIX: fonction manquante ajout√©e
        function updateStats() {
            if (!mapReady) return;
            const year = document.getElementById('year-select').value;
            const lyrId = `lyr-${year}`;
            document.getElementById('stat-zoom').textContent = map.getZoom().toFixed(1);

            if (!map.getLayer(lyrId)) {
                document.getElementById('stat-parcels').textContent = '‚Äî';
                document.getElementById('stat-surface').textContent = '‚Äî';
                document.getElementById('stat-cultures').textContent = '‚Äî';
                return;
            }

            const features = map.queryRenderedFeatures({ layers: [lyrId] });
            document.getElementById('stat-parcels').textContent = features.length.toLocaleString('fr-FR');

            const surface = features.reduce((sum, f) => sum + parseFloat(f.properties.SURF_PARC || 0), 0);
            document.getElementById('stat-surface').textContent = surface.toFixed(1);

            const cultures = new Set(features.map(f => f.properties.CODE_CULTU).filter(Boolean));
            document.getElementById('stat-cultures').textContent = cultures.size;

            renderStatsChart(features);
        }

        function renderStatsChart(features) {
            const ctx = document.getElementById('stats-chart').getContext('2d');
            if (statsChart) statsChart.destroy();

            // Agr√©ger par groupe de culture
            const groups = {};
            features.forEach(f => {
                const code = f.properties.CODE_GROUP || 'Inconnu';
                const label = groupLabels.get(code) || `Groupe ${code}`;
                if (!groups[label]) groups[label] = 0;
                groups[label] += parseFloat(f.properties.SURF_PARC || 0);
            });

            // Trier par surface d√©croissante, garder top 8
            const sorted = Object.entries(groups).sort((a, b) => b[1] - a[1]).slice(0, 8);
            const labels = sorted.map(([k]) => k);
            const data = sorted.map(([, v]) => parseFloat(v.toFixed(1)));
            const bgColors = Object.keys(cultureColors)
                .filter(k => k !== 'default')
                .slice(0, sorted.length)
                .map(k => cultureColors[k]);

            statsChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels, datasets: [{ data, backgroundColor: bgColors, borderWidth: 2, borderColor: '#fff' }] },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: true, position: 'bottom', labels: { font: { size: 10 }, padding: 8, usePointStyle: true } },
                        tooltip: { callbacks: { label: (ctx) => ` ${ctx.label}: ${ctx.parsed.toFixed(1)} ha` } }
                    }
                }
            });
        }

        // ‚îÄ‚îÄ Export CSV ‚îÄ‚îÄ
        // FIX: fonction manquante ajout√©e
        function exportCSV() {
            const year = document.getElementById('year-select').value;
            const lyrId = `lyr-${year}`;
            if (!map.getLayer(lyrId)) { showToast("Aucune couche active", "‚ö†Ô∏è"); return; }

            const features = map.queryRenderedFeatures({ layers: [lyrId] });
            if (!features.length) { showToast("Aucune parcelle visible", "‚ö†Ô∏è"); return; }

            const keys = ['ID_PARCEL', 'CODE_CULTU', 'CODE_GROUP', 'SURF_PARC'];
            const rows = [keys.join(';')];
            const seen = new Set();

            features.forEach(f => {
                const id = f.properties.ID_PARCEL || f.id || '';
                if (seen.has(id)) return;
                seen.add(id);
                rows.push(keys.map(k => f.properties[k] ?? '').join(';'));
            });

            const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `iparcel-export-${year}-${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`${rows.length - 1} parcelles export√©es`, "üì•");
        }

        // ‚îÄ‚îÄ Notes ‚îÄ‚îÄ
        // FIX: fonctions manquantes ajout√©es ‚Äî stockage localStorage
        function saveNote() {
            if (!currentParcelId) { showToast("Aucune parcelle s√©lectionn√©e", "‚ö†Ô∏è"); return; }
            const text = document.getElementById('parcel-note').value.trim();
            if (!text) { showToast("Note vide", "‚ö†Ô∏è"); return; }

            const key = `note_${currentParcelId}`;
            const existing = JSON.parse(localStorage.getItem(key) || '[]');
            existing.unshift({ text, date: new Date().toLocaleString('fr-FR') });
            localStorage.setItem(key, JSON.stringify(existing));

            document.getElementById('parcel-note').value = '';
            loadNotes(currentParcelId);
            showToast("Note sauvegard√©e", "üíæ");
        }

        function loadNotes(parcelId) {
            const key = `note_${parcelId}`;
            const notes = JSON.parse(localStorage.getItem(key) || '[]');
            const box = document.getElementById('saved-notes');
            if (!notes.length) {
                box.innerHTML = '<span style="color:var(--text-muted);">Aucune note.</span>';
                return;
            }
            box.innerHTML = notes.map(n => `
        <div style="background:var(--border-light);border:1px solid var(--border);border-radius:var(--radius-sm);padding:10px;margin-bottom:8px;">
            <div style="font-size:0.7rem;color:var(--text-muted);margin-bottom:4px;">${n.date}</div>
            <div style="color:var(--text-main);">${n.text.replace(/\n/g, '<br>')}</div>
        </div>
    `).join('');
        }

        // ‚îÄ‚îÄ Export PDF ‚îÄ‚îÄ
        // FIX: fonction manquante ‚Äî impression via window.print()
        function exportParcelPDF() {
            if (!currentParcelId) { showToast("Aucune parcelle s√©lectionn√©e", "‚ö†Ô∏è"); return; }
            showToast("Ouverture impression‚Ä¶", "üñ®Ô∏è");
            setTimeout(() => window.print(), 500);
        }

        // ‚îÄ‚îÄ Address Search (BAN API) ‚îÄ‚îÄ
        let searchTimeout;
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('address-input');
            const sugBox = document.getElementById('suggestions');

            input.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const q = input.value.trim();
                if (q.length < 3) { sugBox.classList.remove('open'); return; }
                searchTimeout = setTimeout(async () => {
                    try {
                        const r = await fetch(`https://api-adresse.data.gouv.fr/search/?q=${encodeURIComponent(q)}&limit=5`);
                        const data = await r.json();
                        if (data.features && data.features.length) {
                            sugBox.innerHTML = data.features.map(f => {
                                const label = f.properties.label.replace(/'/g, "\\'");
                                const [lng, lat] = f.geometry.coordinates;
                                return `<button onclick="flyToResult(${lng}, ${lat}, '${label}')">
                            <span class="sug-icon">üìç</span> ${f.properties.label}
                        </button>`;
                            }).join('');
                            sugBox.classList.add('open');
                        } else {
                            sugBox.classList.remove('open');
                        }
                    } catch (e) { sugBox.classList.remove('open'); }
                }, 300);
            });

            input.addEventListener('blur', () => setTimeout(() => sugBox.classList.remove('open'), 200));

            // FIX: event listener pour le slider d'opacit√©
            document.getElementById('opacity-slider').addEventListener('input', function () {
                const val = this.value;
                document.getElementById('opacity-value').textContent = val;
                if (!mapReady) return;
                const year = document.getElementById('year-select').value;
                const lyr = `lyr-${year}`;
                if (map.getLayer(lyr)) map.setPaintProperty(lyr, 'fill-opacity', val / 100);
            });

            // FIX: event listener pour le slider de contour
            document.getElementById('outline-slider').addEventListener('input', function () {
                const val = parseFloat(this.value);
                document.getElementById('outline-value').textContent = val;
                if (!mapReady) return;
                const year = document.getElementById('year-select').value;
                const lyrOutline = `lyr-${year}-outline`;
                if (map.getLayer(lyrOutline)) map.setPaintProperty(lyrOutline, 'line-width', val);
            });

            // FIX: event listener pour le changement d'ann√©e
            document.getElementById('year-select').addEventListener('change', function () {
                if (!mapReady) return;
                const year = this.value;
                const op = document.getElementById('opacity-slider').value / 100;
                ensureLayer(year);
                // Masquer toutes les couches sauf l'ann√©e s√©lectionn√©e
                years.forEach(y => {
                    const lyr = `lyr-${y}`;
                    if (map.getLayer(lyr)) {
                        map.setPaintProperty(lyr, 'fill-opacity', y === year ? op : 0);
                    }
                });
                applyFilter();
                updateStats();
                showToast(`Ann√©e ${year} charg√©e`, "üìÖ");
            });
        });

        function flyToResult(lng, lat, label) {
            map.flyTo({ center: [lng, lat], zoom: 13 });
            document.getElementById('address-input').value = label;
            document.getElementById('suggestions').classList.remove('open');
            showToast(`Navigation vers ${label}`, "üìç");
        }

        // ‚îÄ‚îÄ Weather Fetch ‚îÄ‚îÄ
        async function fetchWeather(lat, lng, year) {
            try {
                const r = await fetch(
                    `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lng}` +
                    `&start_date=${year}-03-01&end_date=${year}-10-31` +
                    `&daily=temperature_2m_mean,precipitation_sum&timezone=Europe%2FParis`
                );
                const d = await r.json();
                if (!d.daily) return null;
                const temps = d.daily.temperature_2m_mean.filter(v => v !== null);
                if (!temps.length) return null;
                const avgT = temps.reduce((a, b) => a + b, 0) / temps.length;
                const sumR = d.daily.precipitation_sum.reduce((a, b) => a + (b || 0), 0);
                return {
                    temp: avgT.toFixed(1),
                    rain: Math.round(sumR),
                    maxT: Math.max(...temps).toFixed(1),
                    minT: Math.min(...temps).toFixed(1),
                    dailyTemps: d.daily.temperature_2m_mean,
                    dailyRain: d.daily.precipitation_sum,
                    dates: d.daily.time
                };
            } catch (e) { return null; }
        }

        // ‚îÄ‚îÄ Bucket loader with cache ‚îÄ‚îÄ
        async function loadBucket(bucketId) {
            if (bucketCache[bucketId]) return bucketCache[bucketId];
            const url = `https://huggingface.co/datasets/Juckles19/iparcel-public/resolve/main/${bucketId}.json`;
            try {
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                bucketCache[bucketId] = data;
                return data;
            } catch (e) {
                console.warn(`[iParcel] Bucket ${bucketId} introuvable`);
                return null;
            }
        }

        // ‚îÄ‚îÄ Build full lineage by walking parent chain recursively ‚îÄ‚îÄ
        async function buildFullLineage(compositeId, maxDepth = 12) {
            const lineage = {};
            let currentUid = compositeId;
            const visited = new Set([currentUid]);

            for (let depth = 0; depth < maxDepth; depth++) {
                const bucket = currentUid.slice(-2);
                const data = await loadBucket(bucket);
                if (!data) break;

                const filiation = data.filiations && data.filiations[currentUid];
                if (!filiation || !filiation.parents || filiation.parents.length === 0) break;

                // Take best parent (highest overlap)
                const bestParent = filiation.parents.reduce((a, b) => (b.pct > a.pct) ? b : a);
                const parentUid = bestParent.uid;
                if (visited.has(parentUid)) break;
                visited.add(parentUid);

                const parentYear = parentUid.split('_')[0];
                const parentIdParcel = parentUid.split('_').slice(1).join('_');

                // Load parent's bucket to get its culture info
                const parentBucket = parentUid.slice(-2);
                const parentData = await loadBucket(parentBucket);
                const parentInfo = parentData && parentData.parcelles && parentData.parcelles[parentUid];

                lineage[parentYear] = {
                    c: parentInfo ? parentInfo.c : '?',
                    g: parentInfo ? parentInfo.g : '',
                    s: parentInfo ? parentInfo.s : null,
                    cf: bestParent.pct,
                    p: parentIdParcel,
                    uid: parentUid,
                };

                currentUid = parentUid;
            }

            return lineage;
        }

        // ‚îÄ‚îÄ Parcel Details ‚îÄ‚îÄ
        async function showDetails(e, parcelId, props) {
            const year = document.getElementById('year-select').value;
            const compositeId = `${year}_${parcelId}`;
            currentParcelId = compositeId;

            console.log(`[iParcel] Recherche : ${compositeId}`);

            document.getElementById('parcel-name').innerHTML = "Chargement...";
            toggleSidebar(true);

            try {
                // Load initial bucket
                const bucket = compositeId.slice(-2);
                const data = await loadBucket(bucket);
                if (!data) throw new Error("Fichier partition introuvable");

                const parcelInfo = data.parcelles && data.parcelles[compositeId];

                // Build full lineage by walking parent chain
                const lineage = await buildFullLineage(compositeId);

                // Build record compatible with original format
                let record = null;
                if (parcelInfo) {
                    record = {
                        ...parcelInfo,
                        c23: parcelInfo.c || props.CODE_CULTU,
                        l: lineage,
                        lineage: lineage,
                    };
                } else {
                    // Parcel not in index ‚Äî use props only
                    record = {
                        c: props.CODE_CULTU,
                        g: props.CODE_GROUP,
                        s: props.SURF_PARC,
                        c23: props.CODE_CULTU,
                        l: lineage,
                        lineage: lineage,
                    };
                }

                // Store in lineageData for compatibility with other functions
                if (!lineageData) lineageData = {};
                lineageData[parcelId] = record;
                lineageData[compositeId] = record;

                // Build parentIndex entries for siblings
                if (!parentIndex) parentIndex = {};
                for (const [yr, entry] of Object.entries(lineage)) {
                    if (entry.p) {
                        const key = `${entry.p}_${yr}`;
                        if (!parentIndex[key]) parentIndex[key] = [];
                        if (!parentIndex[key].includes(parcelId)) parentIndex[key].push(parcelId);
                    }
                }

                // Also index siblings from the bucket filiations
                for (const [uid, fil] of Object.entries(data.filiations || {})) {
                    if (!fil.parents) continue;
                    for (const p of fil.parents) {
                        const pYear = p.uid.split('_')[0];
                        const pId = p.uid.split('_').slice(1).join('_');
                        const childId = uid.split('_').slice(1).join('_');
                        const key = `${pId}_${pYear}`;
                        if (!parentIndex[key]) parentIndex[key] = [];
                        if (!parentIndex[key].includes(childId)) parentIndex[key].push(childId);
                    }
                }

                // --- Display ---
                const cropName = cropLabels[props.CODE_CULTU] || props.CODE_CULTU || "Culture inconnue";
                const groupName = groupLabels.get(props.CODE_GROUP) || props.CODE_GROUP || "";
                const lineageYears = Object.keys(lineage);
                const yearsTracked = lineageYears.length > 0 ? lineageYears.length + 1 : 1;

                document.getElementById('parcel-name').innerHTML = `${cropName} <span class="culture-badge">${groupName}</span>`;

                document.getElementById('info-grid').innerHTML = `
            <div class="info-card"><div class="ic-icon">üÜî</div><div class="ic-value" style="font-size:0.75rem;">${parcelId}</div><div class="ic-label">ID Parcelle</div></div>
            <div class="info-card"><div class="ic-icon">üìê</div><div class="ic-value">${props.SURF_PARC ? parseFloat(props.SURF_PARC).toFixed(2) : '‚Äî'} ha</div><div class="ic-label">Surface</div></div>
            <div class="info-card"><div class="ic-icon">üìÖ</div><div class="ic-value">${yearsTracked} an${yearsTracked > 1 ? 's' : ''}</div><div class="ic-label">Historique</div></div>
            <div class="info-card"><div class="ic-icon">üåæ</div><div class="ic-value">${props.CODE_CULTU || '‚Äî'}</div><div class="ic-label">Code culture</div></div>
        `;

                // M√©t√©o
                const w = await fetchWeather(e.lngLat.lat, e.lngLat.lng, year);
                if (w) renderWeatherChart(w);

                // Historique ‚Äî pass the record with full lineage
                renderHistoryWithRecord(compositeId, props, record);
                // Dans showDetails, juste apr√®s renderHistoryWithRecord(compositeId, props, record);
                renderRotationHeatmap(compositeId, record, data);
                // Mini-map
                if (highlightedFeature) initParcelViz(parcelId, highlightedFeature, props);

            } catch (err) {
                console.error("Erreur de r√©cup√©ration des donn√©es :", err);
                document.getElementById('parcel-name').innerHTML = "Donn√©es indisponibles";
            }
        }

        function renderWeatherChart(w) {
            const ctx = document.getElementById('weather-chart').getContext('2d');
            if (weatherChart) weatherChart.destroy();

            const months = {};
            w.dates.forEach((d, i) => {
                const m = d.slice(0, 7);
                if (!months[m]) months[m] = { temps: [], rain: 0 };
                if (w.dailyTemps[i] !== null) months[m].temps.push(w.dailyTemps[i]);
                months[m].rain += (w.dailyRain[i] || 0);
            });

            const labels = Object.keys(months).map(m => {
                const mo = parseInt(m.split('-')[1]);
                return ['Jan', 'F√©v', 'Mar', 'Avr', 'Mai', 'Jun', 'Jul', 'Ao√ª', 'Sep', 'Oct', 'Nov', 'D√©c'][mo - 1];
            });
            const tempData = Object.values(months).map(m =>
                m.temps.length ? (m.temps.reduce((a, b) => a + b, 0) / m.temps.length).toFixed(1) : null
            );
            const rainData = Object.values(months).map(m => Math.round(m.rain));

            weatherChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Pr√©cipitations (mm)', data: rainData,
                            backgroundColor: 'rgba(59,130,246,0.3)', borderColor: '#3b82f6',
                            borderWidth: 1, borderRadius: 4, yAxisID: 'y1'
                        },
                        {
                            label: 'Temp√©rature (¬∞C)', data: tempData,
                            type: 'line', borderColor: '#ef4444',
                            backgroundColor: 'rgba(239,68,68,0.1)', fill: true,
                            tension: 0.4, pointRadius: 3, pointBackgroundColor: '#ef4444',
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: true, labels: { font: { size: 10 }, usePointStyle: true } } },
                    scales: {
                        y: { position: 'left', title: { display: true, text: '¬∞C', font: { size: 10 } }, grid: { color: '#f1f5f9' } },
                        y1: { position: 'right', title: { display: true, text: 'mm', font: { size: 10 } }, grid: { display: false } },
                        x: { grid: { display: false } }
                    }
                }
            });
        }

        // ‚îÄ‚îÄ Compute global stats from lineage ‚îÄ‚îÄ
        function computeLineageStats(data) {
            let total = 0, withHistory = 0, monocultures = 0, splits = 0;
            let totalChanges = 0, maxDepth = 0;
            const allCultures = {};

            for (const [pid, rec] of Object.entries(data)) {
                total++;
                const lin = rec.lineage || rec.l;
                if (!lin || Object.keys(lin).length === 0) continue;
                withHistory++;
                const years = Object.keys(lin);
                if (years.length > maxDepth) maxDepth = years.length;

                // Culture tracking
                const currentCode = rec.c23 || rec["culture_2023"] || '';
                const cultures = [currentCode];
                const parentIds = new Set();
                let prev = currentCode;
                for (const y of years.sort((a, b) => b - a)) {
                    const code = lin[y].c || lin[y].culture || '';
                    cultures.push(code);
                    if (code && code !== prev && prev) totalChanges++;
                    prev = code;
                    const p = lin[y].p || lin[y].parent_id;
                    if (p) parentIds.add(p);
                    // Low confidence = probable split
                    const cf = lin[y].cf ?? lin[y].confidence;
                    if (cf !== null && cf !== undefined && cf < 0.5) splits++;
                }
                const uniqueCultures = new Set(cultures.filter(c => c && c !== '‚Äî'));
                if (uniqueCultures.size === 1 && cultures.length > 2) monocultures++;

                cultures.forEach(c => { if (c && c !== '‚Äî') allCultures[c] = (allCultures[c] || 0) + 1; });
            }

            // Top cultures
            const topCultures = Object.entries(allCultures)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            return { total, withHistory, monocultures, splits, totalChanges, maxDepth, topCultures };
        }

        // ‚îÄ‚îÄ Render global lineage stats in Stats tab ‚îÄ‚îÄ
        function renderLineageGlobalStats() {
            const container = document.getElementById('lineage-global-stats');
            if (!container || !lineageStats) { if (container) container.innerHTML = ''; return; }
            const s = lineageStats;

            const topCultHtml = s.topCultures.map(([code, count]) => {
                const name = cropLabels[code] || code;
                return `<span class="stat-pill">${name}: ${count.toLocaleString('fr-FR')}</span>`;
            }).join('');

            container.innerHTML = `
        <label style="margin-top:18px;">üß¨ G√©n√©alogie des parcelles</label>
        <div class="quick-stats" style="grid-template-columns:1fr 1fr;">
            <div class="stat-card">
                <div class="stat-value">${s.withHistory.toLocaleString('fr-FR')}</div>
                <div class="stat-label">Parcelles avec historique</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${s.maxDepth + 1} ans</div>
                <div class="stat-label">Profondeur max</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${s.monocultures.toLocaleString('fr-FR')}</div>
                <div class="stat-label">Monocultures d√©tect√©es</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${s.splits.toLocaleString('fr-FR')}</div>
                <div class="stat-label">D√©coupes probables</div>
            </div>
        </div>
        <label style="margin-top:12px;">üèÜ Cultures les plus fr√©quentes (historique)</label>
        <div class="weather-stats" style="margin-top:6px;">${topCultHtml}</div>
    `;
        }

        // ‚îÄ‚îÄ Find siblings: parcels sharing the same parent in a given year ‚îÄ‚îÄ
        function findSiblings(parcelId, record) {
            if (!record || !parentIndex) return [];
            const lineage = record.lineage || record.l || {};
            const years = Object.keys(lineage).sort((a, b) => b - a);
            const seen = new Set();
            const siblings = [];

            for (const yr of years) {
                const parentId = lineage[yr].p || lineage[yr].parent_id;
                if (!parentId) continue;
                const key = `${parentId}_${yr}`;
                const sibs = parentIndex[key] || [];
                for (const sibId of sibs) {
                    if (sibId === parcelId || seen.has(sibId)) continue;
                    seen.add(sibId);
                    const sibRec = lineageData[sibId];
                    if (!sibRec) continue;
                    // Get sibling's culture for that year
                    const sibLin = sibRec.lineage || sibRec.l || {};
                    const sibEntry = sibLin[yr];
                    siblings.push({
                        id: sibId,
                        year: yr,
                        parentId: parentId,
                        culture: sibEntry ? (sibEntry.c || sibEntry.culture) : (sibRec.c23 || '?'),
                        confidence: sibEntry ? (sibEntry.cf ?? sibEntry.confidence) : null,
                    });
                }
            }
            return siblings;
        }

        // ‚îÄ‚îÄ Render siblings ‚îÄ‚îÄ
        function renderSiblings(siblings) {
            const container = document.getElementById('siblings-container');
            if (!container) return;
            if (!siblings || siblings.length === 0) {
                container.innerHTML = '';
                return;
            }

            const items = siblings.slice(0, 8).map(s => {
                const cropName = cropLabels[s.culture] || s.culture || '?';
                const conf = s.confidence !== null ? Math.round(s.confidence * 100) : null;
                return `
            <div class="parent-card" style="margin-bottom:6px;cursor:pointer;" 
                 title="Parcelle s≈ìur issue du m√™me parent ${s.parentId} en ${s.year}">
                <div class="parent-card-header">
                    <div class="culture-dot" style="background:${getCultureColor('')}"></div>
                    <div style="font-weight:600;color:var(--text-main);font-size:0.82rem;">${cropName}</div>
                    <div style="margin-left:auto;font-size:0.68rem;color:var(--text-muted);">
                        üÜî ${s.id}
                    </div>
                </div>
                <div style="font-size:0.68rem;color:var(--text-muted);margin-top:3px;">
                    Ann√©e ${s.year} ¬∑ Parent: ${s.parentId}${conf !== null ? ` ¬∑ Fiabilit√©: ${conf}%` : ''}
                </div>
            </div>`;
            }).join('');

            container.innerHTML = `
        <div style="background:linear-gradient(135deg,#fefce8,#fef9c3);border:1.5px solid #fde68a;border-radius:var(--radius-sm);padding:14px;margin-bottom:14px;">
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:10px;">
                <span style="font-size:0.75rem;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:#92400e;">
                    ‚úÇÔ∏è Parcelles s≈ìurs
                </span>
                <span style="font-size:0.65rem;background:#fbbf24;color:white;padding:2px 8px;border-radius:10px;font-weight:700;">
                    ${siblings.length}
                </span>
            </div>
            <div style="font-size:0.72rem;color:#a16207;margin-bottom:8px;">
                Issues du m√™me d√©coupage parcellaire
            </div>
            ${items}
            ${siblings.length > 8 ? `<div style="font-size:0.7rem;color:var(--text-muted);margin-top:6px;">+ ${siblings.length - 8} autres</div>` : ''}
        </div>`;
        }

        // ‚îÄ‚îÄ renderHistory ‚Äî enhanced with siblings, mutation detection, parent navigation ‚îÄ‚îÄ
        function getCultureColor(codeGroup) {
            return cultureColors[codeGroup] || cultureColors.default;
        }

        function computeRotationScore(cultures) {
            const valid = cultures.filter(c => c && c !== '‚Äî' && c !== '');
            if (valid.length <= 1) return { score: 0, label: 'Donn√©es insuffisantes', level: 'moderate' };
            const unique = new Set(valid);
            const ratio = unique.size / valid.length;
            const score = Math.round(ratio * 10);
            let label, level;
            if (unique.size === 1) {
                label = 'Monoculture'; level = 'bad';
            } else if (ratio < 0.4) {
                label = 'Rotation faible'; level = 'moderate';
            } else if (ratio < 0.7) {
                label = 'Rotation correcte'; level = 'moderate';
            } else {
                label = 'Rotation diversifi√©e'; level = 'good';
            }
            return { score, label, level, unique: unique.size, total: valid.length };
        }
        let spatialHeatmapMap = null;

        async function renderSpatialHeatmap(parcelId, feature, record, bucketData) {
            const container = document.getElementById('spatial-heatmap-container');

            // Nettoyage de l'ancienne instance
            if (spatialHeatmapMap) { spatialHeatmapMap.remove(); spatialHeatmapMap = null; }

            // 1. Calcul des scores pour chaque branche (parent)
            const filiation = bucketData.filiations && bucketData.filiations[parcelId];
            const parents = filiation ? filiation.parents : [];
            const scores = {};

            // Calculer le score de chaque parent trouv√© dans le bucket
            for (const p of parents) {
                const branchLineage = await buildFullLineage(p.uid);
                const codes = Object.values(branchLineage).map(l => l.c).filter(c => c && c !== '?');
                const uniqueRatio = new Set(codes).size / (codes.length || 1);

                // Attribution d'une couleur : Rouge (Monoculture) -> Vert (Diversifi√©)
                let color = "#ef4444"; // Rouge
                if (uniqueRatio > 0.7) color = "#10b981"; // Vert
                else if (uniqueRatio > 0.4) color = "#f59e0b"; // Orange

                scores[p.uid] = color;
            }

            // 2. Initialisation de la mini-carte spatiale
            const bbox = getFeatureBboxFromGeom(feature.geometry);
            spatialHeatmapMap = new maplibregl.Map({
                container: 'spatial-heatmap-container',
                style: { version: 8, sources: {}, layers: [{ id: 'bg', type: 'background', paint: { 'background-color': '#f1f5f9' } }] },
                bounds: [[bbox[0], bbox[1]], [bbox[2], bbox[3]]],
                fitBoundsOptions: { padding: 20 },
                interactive: false, attributionControl: false
            });

            spatialHeatmapMap.on('load', () => {
                const year = document.getElementById('year-select').value;
                const srcId = `heatmap-src`;

                // Charger la couche de l'ann√©e pr√©c√©dente pour voir les divisions
                spatialHeatmapMap.addSource(srcId, {
                    type: 'vector',
                    url: `pmtiles://https://huggingface.co/datasets/Juckles19/iparcel-public/resolve/main/${year}.pmtiles`
                });

                // Coloration spatiale : on matche l'UID du parent avec sa couleur de score
                const colorExpression = ["match", ["get", "id_parcel"]]; // ou l'ID utilis√© dans tes pmtiles
                Object.entries(scores).forEach(([uid, color]) => {
                    const idOnly = uid.split('_')[1];
                    colorExpression.push(idOnly, color);
                });
                colorExpression.push("rgba(0,0,0,0.05)"); // Parcelles voisines transparentes

                spatialHeatmapMap.addLayer({
                    id: 'heatmap-layer-fill', type: 'fill', source: srcId, 'source-layer': 'parcelles',
                    paint: { 'fill-color': colorExpression, 'fill-opacity': 0.8 }
                });

                // Contour de la parcelle actuelle 2023 pour r√©f√©rence
                spatialHeatmapMap.addSource('outline-2023', {
                    type: 'geojson',
                    data: { type: 'Feature', geometry: feature.geometry }
                });
                spatialHeatmapMap.addLayer({
                    id: 'outline-2023-line', type: 'line', source: 'outline-2023',
                    paint: { 'line-color': '#000', 'line-width': 2 }
                });

                // Mise √† jour de l'UI
                const avgScore = Object.keys(scores).length > 0 ? "Analyse Multi-zones" : "Zone Unique";
                document.getElementById('heatmap-score-label').textContent = avgScore;
                document.getElementById('heatmap-score-value').textContent =
                    Object.keys(scores).length > 1 ? "Fusion d√©tect√©e" : "Historique stable";
            });
        }
        function renderRotationScore(scoreData) {
            const container = document.getElementById('rotation-score');
            if (!scoreData || scoreData.total < 2) {
                container.innerHTML = '';
                return;
            }
            const cardClass = scoreData.level === 'good' ? '' : scoreData.level === 'bad' ? ' mono' : ' moderate';
            const pct = Math.min(100, scoreData.score * 10);
            const strokeColor = scoreData.level === 'good' ? '#10b981' : scoreData.level === 'bad' ? '#ef4444' : '#f59e0b';
            const circumference = 2 * Math.PI * 20;
            const offset = circumference - (pct / 100) * circumference;

            container.innerHTML = `
        <div class="rotation-score-card${cardClass}">
            <div class="rotation-header">
                <div>
                    <div class="rotation-label">Diversit√© des cultures</div>
                    <div style="font-size:0.85rem;font-weight:600;color:var(--text-main);margin-top:4px;">
                        ${scoreData.unique} culture${scoreData.unique > 1 ? 's' : ''} diff√©rente${scoreData.unique > 1 ? 's' : ''} sur ${scoreData.total} ans
                    </div>
                </div>
                <div style="display:flex;flex-direction:column;align-items:center;">
                    <div class="rotation-score-ring">
                        <svg width="52" height="52" viewBox="0 0 52 52">
                            <circle cx="26" cy="26" r="20" fill="none" stroke="#e2e8f0" stroke-width="5"/>
                            <circle cx="26" cy="26" r="20" fill="none" stroke="${strokeColor}" stroke-width="5"
                                stroke-dasharray="${circumference}" stroke-dashoffset="${offset}"
                                stroke-linecap="round" style="transition:stroke-dashoffset 1s ease"/>
                        </svg>
                        <div class="score-text">${scoreData.score}</div>
                    </div>
                    <span class="rotation-badge ${scoreData.level}">${scoreData.label}</span>
                </div>
            </div>
        </div>`;
        }

        function renderTimelineStrip(entries) {
            const container = document.getElementById('timeline-strip-container');
            if (!entries || entries.length < 2) { container.innerHTML = ''; return; }

            const cells = entries.map(e => {
                const bg = e.cultureGroup ? getCultureColor(e.cultureGroup) : '#cbd5e1';
                const cls = e.isCurrent ? ' current' : (e.empty ? ' empty' : '');
                const code = e.cultureCode || '?';
                return `<div class="strip-cell${cls}" style="background:${e.empty ? '' : bg}"
                    title="${e.year}: ${cropLabels[code] || code}${e.confidence != null ? ' (fiabilit√© ' + Math.round(e.confidence * 100) + '%)' : ''}"">
                    <span class="strip-year">${String(e.year).slice(2)}</span>
                    <span class="strip-code">${code}</span>
                </div>`;
            }).join('');

            container.innerHTML = `<div class="timeline-strip">${cells}</div>`;
        }

        function renderHistoryWithRecord(parcelId, props, record) {
            const list = document.getElementById('history-list');
            const currentYear = document.getElementById('year-select').value;

            if (!record) {
                renderRotationScore(null);
                renderTimelineStrip(null);
                list.innerHTML = `<div class="history-item"><div class="year-badge current">${currentYear}</div><p>Aucun historique trouv√© pour cette parcelle.</p></div>`;
                return;
            }

            const lineage = record.lineage || record.l || {};
            const sortedYears = Object.keys(lineage).sort((a, b) => b - a);

            // Build timeline entries
            const allEntries = [{
                year: parseInt(currentYear),
                cultureCode: record.c || record.c23 || props.CODE_CULTU,
                cultureGroup: record.g || props.CODE_GROUP,
                isCurrent: true
            }];
            const allCultures = [record.c || record.c23 || props.CODE_CULTU];

            sortedYears.forEach(y => {
                const entry = lineage[y];
                const code = entry.c || entry.culture || '‚Äî';
                allEntries.push({
                    year: parseInt(y),
                    cultureCode: code,
                    cultureGroup: entry.g || '',
                    confidence: entry.cf,
                    isCurrent: false
                });
                allCultures.push(code);
            });

            renderRotationScore(computeRotationScore(allCultures));
            renderTimelineStrip(allEntries.sort((a, b) => a.year - b.year));
            // Remplace l'ancien appel par celui-ci
            renderSpatialHeatmap(compositeId, highlightedFeature, record, data);

            // Detailed timeline
            const currentCropName = cropLabels[record.c || record.c23 || props.CODE_CULTU] || record.c || props.CODE_CULTU;
            let html = `
        <div class="history-item">
            <div class="timeline-dot"></div>
            <div class="year-badge current">${currentYear}</div>
            <div class="parent-card">
                <div class="parent-card-header">
                    <div class="culture-dot" style="background:${getCultureColor(record.g || props.CODE_GROUP)}"></div>
                    <div style="font-weight:600;color:var(--text-main);">${currentCropName}</div>
                </div>
                <div style="font-size:0.75rem;color:var(--text-muted);margin-top:4px;">${props.SURF_PARC ? parseFloat(props.SURF_PARC).toFixed(2) + ' ha' : '‚Äî'}</div>
            </div>
        </div>`;

            let prevCulture = record.c || record.c23 || props.CODE_CULTU;

            html += sortedYears.map(y => {
                const entry = lineage[y];
                const code = entry.c || entry.culture || '‚Äî';
                const cropName = cropLabels[code] || code;
                const confidence = entry.cf != null ? Math.round(entry.cf * 100) : null;
                const parentId = entry.p || entry.parent_id || null;
                const parentUid = entry.uid || (parentId ? `${y}_${parentId}` : null);
                const surface = entry.s ? parseFloat(entry.s).toFixed(2) + ' ha' : '';
                const cultureChanged = code !== prevCulture && code !== '‚Äî' && prevCulture !== '‚Äî';
                const groupColor = entry.g ? getCultureColor(entry.g) : getCultureColor('');
                prevCulture = code;

                return `
            <div class="history-item">
                <div class="timeline-dot past ${confidence !== null && confidence < 50 ? 'event-split' : ''}"></div>
                <div class="year-badge">
                    ${y} 
                    ${confidence !== null && confidence < 50 ? `<span class="event-tag split">‚úÇÔ∏è D√©coupe probable</span>` : ''}
                    ${cultureChanged ? '<span class="event-tag new">üîÑ Changement</span>' : ''}
                </div>
                <div class="parent-card">
                    <div class="parent-card-header">
                        <div class="culture-dot" style="background:${groupColor}"></div>
                        <div style="font-weight:600;color:var(--text-main);">${cropName}</div>
                    </div>
                    ${surface ? `<div style="font-size:0.72rem;color:var(--text-muted);margin-top:2px;">üìê ${surface}</div>` : ''}
                    ${confidence !== null ? `
                        <div class="confidence-bar"><div class="confidence-fill" style="width:${confidence}%"></div></div>
                        <span style="font-size:0.7rem;color:var(--text-muted);">Fiabilit√©: ${confidence}%</span>
                    ` : ''}
                    ${parentUid ? `<br><span style="font-size:0.65rem;color:var(--text-muted);cursor:pointer;" onclick="loadParent('${parentUid}')">üîó Parent: ${parentId || parentUid}</span>` : ''}
                </div>
            </div>`;
            }).join('');

            list.innerHTML = html;
        }

        async function renderRotationHeatmap(parcelId, record, bucketData) {
            const root = document.getElementById('heatmap-grid-root');
            root.innerHTML = '<div class="skeleton" style="height:100px;"></div>';

            // 1. Identifier les branches historiques (Filiations depuis le bucket)
            const filiation = bucketData.filiations && bucketData.filiations[parcelId];
            const parents = filiation ? filiation.parents : [];

            // Si pas de parents, on traite la parcelle comme une branche unique
            const branches = parents.length > 0 ? parents : [{ uid: parcelId, pct: 1 }];
            root.innerHTML = '';

            for (const p of branches) {
                const branchDiv = document.createElement('div');
                branchDiv.className = 'heatmap-branch';

                // Reconstruction de l'historique pour cette branche sp√©cifique
                // On utilise ta fonction buildFullLineage pour remonter le temps
                const branchLineage = await buildFullLineage(p.uid);
                const yearsList = ["2023", "2022", "2021", "2020", "2019", "2018", "2017", "2016"];

                // Calcul du score de diversit√©
                const codes = yearsList.map(y => (y === "2023" && p.uid === parcelId) ? (record.c || record.c23) : (branchLineage[y]?.c)).filter(c => c && c !== '?');
                const uniqueCount = new Set(codes).size;
                const ratio = uniqueCount / codes.length;

                let healthColor = "#10b981"; // Vert (Bien)
                if (ratio < 0.4) healthColor = "#ef4444"; // Rouge (Mauvais)
                else if (ratio < 0.7) healthColor = "#f59e0b"; // Orange (Moyen)

                branchDiv.innerHTML = `
            <div class="branch-info">
                <span style="font-weight:700;">Branche ID: ${p.uid.split('_').pop()}</span>
                <div style="display:flex; align-items:center; gap:6px;">
                    <span style="font-size:0.65rem; color:var(--text-muted);">${uniqueCount} cultures / ${codes.length} ans</span>
                    <div class="health-dot" style="background:${healthColor}"></div>
                </div>
            </div>
            <div class="heatmap-row">
                ${yearsList.map(y => {
                    const isNow = (y === "2023" && p.uid === parcelId);
                    const cultCode = isNow ? (record.c || record.c23) : (branchLineage[y]?.c || null);
                    const group = isNow ? (record.g) : (branchLineage[y]?.g || '');
                    const color = cultCode ? getCultureColor(group) : '#e2e8f0';
                    const name = cropLabels[cultCode] || cultCode || 'Inconnu';
                    return `<div class="heatmap-cell" style="background:${color}" title="${y} : ${name}"></div>`;
                }).join('')}
            </div>
        `;
                root.appendChild(branchDiv);
            }
        }

        // Petite fonction bonus pour naviguer vers le parent au clic
        window.loadParent = function (parentId) {
            if (!parentId || parentId === 'undefined') return;
            const year = parentId.split('_')[0];
            document.getElementById('year-select').value = year;
            document.getElementById('year-select').dispatchEvent(new Event('change'));
            // Ici on pourrait ajouter un flyTo vers le parent si on avait ses coordonn√©es
            showToast(`Passage √† la campagne ${year}`, "üìÖ");
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ‚îÄ‚îÄ PARCEL VISUALIZATION ‚Äî MINI-MAP ENGINE ‚îÄ‚îÄ
        // Creates a secondary MapLibre map in the sidebar showing
        // the 2023 parcel outline (black) overlaid on the year layer
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        let miniMap = null;
        let miniMapReady = false;
        let parcelVizState = {
            parcelId: null,
            feature: null,
            yearIndex: 0,
            years: [],
            yearData: {},
            animTimer: null,
            currentVisibleYear: null,
        };

        function destroyMiniMap() {
            if (parcelVizState.animTimer) {
                clearInterval(parcelVizState.animTimer);
                parcelVizState.animTimer = null;
            }
            if (miniMap) {
                miniMap.remove();
                miniMap = null;
                miniMapReady = false;
            }
        }

        function initParcelViz(parcelId, feature, props) {
            destroyMiniMap();

            const record = lineageData && lineageData[parcelId];
            const lineage = record ? (record.lineage || record.l || {}) : {};
            const currentYear = parseInt(document.getElementById('year-select').value);
            const currentCulture = props.CODE_CULTU || '‚Äî';
            const currentGroup = props.CODE_GROUP || '';

            const lineageYears = Object.keys(lineage).map(Number).sort();
            const allYears = [...new Set([...lineageYears, currentYear])].sort();

            const yearData = {};
            for (const y of allYears) {
                if (y === currentYear) {
                    yearData[y] = { culture: currentCulture, group: currentGroup, confidence: null, parentId: null, isCurrent: true };
                } else {
                    const entry = lineage[String(y)];
                    if (entry) {
                        yearData[y] = {
                            culture: entry.c || entry.culture || '?',
                            group: entry.g || '',
                            confidence: entry.cf ?? entry.confidence,
                            parentId: entry.p || entry.parent_id || null, isCurrent: false,
                        };
                    }
                }
            }

            parcelVizState = {
                parcelId, feature,
                yearIndex: allYears.length - 1,
                years: allYears, yearData,
                animTimer: null, currentVisibleYear: null,
            };

            // Setup slider
            const slider = document.getElementById('parcel-viz-slider');
            slider.max = allYears.length - 1;
            slider.value = allYears.length - 1;
            slider.oninput = function () {
                parcelVizState.yearIndex = parseInt(this.value);
                switchMiniMapYear();
            };
            document.getElementById('parcel-viz-year-labels').innerHTML =
                allYears.map(y => `<span>${y}</span>`).join('');

            // Compute bbox from feature geometry (expanded to show neighbors)
            const bbox = getFeatureBboxFromGeom(feature.geometry);
            if (!bbox) return;

            const outlineGeoJSON = {
                type: 'FeatureCollection',
                features: [{ type: 'Feature', geometry: feature.geometry, properties: {} }]
            };

            const container = document.getElementById('parcel-viz-svg');
            container.innerHTML = '';

            // Use same basemap as main map
            const mainBasemapTiles = basemaps[0].tiles;

            miniMap = new maplibregl.Map({
                container: container,
                style: {
                    version: 8,
                    sources: {},
                    layers: [{
                        id: 'white-bg', type: 'background',
                        paint: { 'background-color': '#ffffff' }
                    }]
                },
                bounds: [[bbox[0], bbox[1]], [bbox[2], bbox[3]]],
                fitBoundsOptions: { padding: 10 },
                interactive: false,
                attributionControl: false,
            });

            miniMap.on('load', () => {
                miniMapReady = true;

                // Add PMTiles source+layers for each year
                for (const y of allYears) {
                    const srcId = `mini-src-${y}`;
                    miniMap.addSource(srcId, {
                        type: 'vector',
                        url: `pmtiles://https://huggingface.co/datasets/Juckles19/iparcel-public/resolve/main/${y}.pmtiles`
                    });
                    miniMap.addLayer({
                        id: `mini-fill-${y}`, type: 'fill', source: srcId, 'source-layer': 'parcelles',
                        paint: { 'fill-color': getMapColorExpression(), 'fill-opacity': 0, 'fill-outline-color': 'rgba(255,255,255,0.4)' }
                    });
                    miniMap.addLayer({
                        id: `mini-line-${y}`, type: 'line', source: srcId, 'source-layer': 'parcelles',
                        paint: { 'line-color': 'rgba(255,255,255,0.7)', 'line-width': 0.8, 'line-opacity': 0 }
                    });
                }

                // 2023 parcel outline ‚Äî always on top
                miniMap.addSource('parcel-outline-src', { type: 'geojson', data: outlineGeoJSON });
                miniMap.addLayer({
                    id: 'parcel-outline-fill', type: 'fill', source: 'parcel-outline-src',
                    paint: { 'fill-color': '#000000', 'fill-opacity': 0.06 }
                });
                miniMap.addLayer({
                    id: 'parcel-outline-line', type: 'line', source: 'parcel-outline-src',
                    paint: { 'line-color': '#000000', 'line-width': 3, 'line-opacity': 1 }
                });

                switchMiniMapYear();
            });
        }

        function switchMiniMapYear() {
            if (!miniMap || !miniMapReady) return;
            const state = parcelVizState;
            const year = state.years[state.yearIndex];
            const yd = state.yearData[year];

            document.getElementById('parcel-viz-year').textContent = year;

            // Hide previous year layers
            if (state.currentVisibleYear && state.currentVisibleYear !== year) {
                const py = state.currentVisibleYear;
                if (miniMap.getLayer(`mini-fill-${py}`)) miniMap.setPaintProperty(`mini-fill-${py}`, 'fill-opacity', 0);
                if (miniMap.getLayer(`mini-line-${py}`)) miniMap.setPaintProperty(`mini-line-${py}`, 'line-opacity', 0);
            }

            // Show selected year layers
            if (miniMap.getLayer(`mini-fill-${year}`)) miniMap.setPaintProperty(`mini-fill-${year}`, 'fill-opacity', 0.75);
            if (miniMap.getLayer(`mini-line-${year}`)) miniMap.setPaintProperty(`mini-line-${year}`, 'line-opacity', 1);

            state.currentVisibleYear = year;
            updateVizLegendInfo(year, yd);
        }

        function updateVizLegendInfo(year, yd) {
            const legendEl = document.getElementById('parcel-viz-legend');
            const infoEl = document.getElementById('parcel-viz-info');
            if (!yd) { legendEl.innerHTML = ''; infoEl.innerHTML = ''; return; }

            const cultureName = cropLabels[yd.culture] || yd.culture;
            // Use group color from cultureColors (same as main map)
            const groupColor = yd.group ? (cultureColors[yd.group] || cultureColors.default) : cultureColors.default;
            let legendHtml = `<span class="viz-legend-item">
                <span class="viz-legend-swatch" style="background:${groupColor}"></span>${cultureName}</span>`;

            let infoHtml = `<strong>${year}</strong> ¬∑ ${cultureName}`;
            const conf = yd.confidence != null ? Math.round(yd.confidence * 100) : null;
            if (conf !== null) infoHtml += ` ¬∑ Fiabilit√©: ${conf}%`;
            if (yd.parentId) {
                infoHtml += `<br>üîó Parent: <code style="font-size:0.72rem;background:var(--border-light);padding:1px 5px;border-radius:4px;">${yd.parentId}</code>`;
                if (parentIndex) {
                    const key = `${yd.parentId}_${year}`;
                    const siblings = (parentIndex[key] || []).filter(id => id !== parcelVizState.parcelId);
                    if (siblings.length > 0) {
                        infoHtml += `<br><span style="color:#d97706;font-weight:600;">‚úÇÔ∏è ${siblings.length + 1} parcelles dans ce d√©coupage</span>`;
                        for (const sibId of siblings.slice(0, 4)) {
                            const sibRec = lineageData && lineageData[sibId];
                            if (sibRec) {
                                const sibLin = sibRec.lineage || sibRec.l || {};
                                const sibEntry = sibLin[String(year)];
                                if (sibEntry) {
                                    const sc = sibEntry.c || '?';
                                    // Look up group for sibling from current year's c23 or fallback
                                    const sibGroup = sibRec.g23 || '';
                                    const sibColor = sibGroup ? (cultureColors[sibGroup] || cultureColors.default) : cultureColors.default;
                                    legendHtml += `<span class="viz-legend-item">
                                        <span class="viz-legend-swatch" style="background:${sibColor}"></span>${cropLabels[sc] || sc}</span>`;
                                }
                            }
                        }
                    }
                }
            }
            if (yd.isCurrent) infoHtml += `<br><span style="color:var(--accent);font-weight:600;">üìç Ann√©e courante</span>`;
            infoHtml += `<br><span style="font-size:0.7rem;color:var(--text-muted);">‚ñ¨ Contour noir = parcelle 2023</span>`;

            legendEl.innerHTML = legendHtml;
            infoEl.innerHTML = infoHtml;
        }

        function getFeatureBboxFromGeom(geometry) {
            if (!geometry) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const coords = geometry.type === 'MultiPolygon' ? geometry.coordinates.flat(2) :
                geometry.type === 'Polygon' ? geometry.coordinates.flat() : [];
            for (const [x, y] of coords) {
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            }
            if (!isFinite(minX)) return null;
            const dx = (maxX - minX) * 0.3;
            const dy = (maxY - minY) * 0.3;
            return [minX - dx, minY - dy, maxX + dx, maxY + dy];
        }

        function getCultureColorByCulture(code) {
            if (!code || code === '?' || code === '‚Äî') return '#94a3b8';
            let hash = 0;
            for (let i = 0; i < code.length; i++) hash = code.charCodeAt(i) + ((hash << 5) - hash);
            return `hsl(${Math.abs(hash) % 360}, 65%, 50%)`;
        }

        function parcelVizPrev() {
            if (parcelVizState.yearIndex > 0) {
                parcelVizState.yearIndex--;
                document.getElementById('parcel-viz-slider').value = parcelVizState.yearIndex;
                switchMiniMapYear();
            }
        }
        function parcelVizNext() {
            if (parcelVizState.yearIndex < parcelVizState.years.length - 1) {
                parcelVizState.yearIndex++;
                document.getElementById('parcel-viz-slider').value = parcelVizState.yearIndex;
                switchMiniMapYear();
            }
        }
        function parcelVizPlay() {
            const state = parcelVizState;
            const btn = document.getElementById('parcel-viz-play-btn');
            if (state.animTimer) {
                clearInterval(state.animTimer); state.animTimer = null;
                btn.textContent = '‚ñ∂ Animer'; return;
            }
            btn.textContent = '‚è∏ Pause';
            state.yearIndex = 0;
            document.getElementById('parcel-viz-slider').value = 0;
            switchMiniMapYear();
            state.animTimer = setInterval(() => {
                if (state.yearIndex >= state.years.length - 1) {
                    clearInterval(state.animTimer); state.animTimer = null;
                    btn.textContent = '‚ñ∂ Animer'; return;
                }
                state.yearIndex++;
                document.getElementById('parcel-viz-slider').value = state.yearIndex;
                switchMiniMapYear();
            }, 1200);
        }

    </script>
</body>

</html>